{
  "minerType": {
    "name": "Night - (Midnight Miner)",
    "description": "Using a custom binary build of  (Nocturne) (Must install Python Locally)",
    "installScript": "import os, time, subprocess, tempfile\r\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\r\n\r\nADB = os.environ.get(\"adb_path\", \"adb\")\r\ndevices = os.environ.get(\"devices\", \"\").split()\r\n\r\n# --- Nocturne Miner installer & initializer ---\r\ninstall_script_template = r'''#!/data/data/com.termux/files/usr/bin/bash\r\nset -e\r\nexport DEBIAN_FRONTEND=noninteractive\r\nexport TERMUX_PKG_NO_PROMPT=1\r\n\r\nSERIAL_ID=\"{device_id}\"\r\n\r\necho \"[*] Preparing environment...\"\r\npkg update -y || true\r\npkg upgrade -y || true\r\npkg install -y wget tar || true\r\n\r\necho \"[*] Disabling nvm auto-load...\"\r\nsed -i '/nvm.sh/d' ~/.bashrc 2>/dev/null || true\r\nsed -i '/NVM_DIR/d' ~/.bashrc 2>/dev/null || true\r\n\r\necho \"[*] Creating working directory...\"\r\nmkdir -p ~/night\r\ncd ~/night\r\n\r\necho \"[*] Downloading Nocturne Miner...\"\r\nwget -q --show-progress https://cdn.nocturne.offchain.club/releases/v1.1.0/nocturne-miner-android-arm64.tar.gz\r\n\r\necho \"[*] Extracting miner...\"\r\ntar -xvf nocturne-miner-android-arm64.tar.gz\r\nchmod +x nocturne-miner\r\n\r\necho \"[*] Running first-time setup...\"\r\n# Feed serial id then 3 enters for defaults\r\nprintf \"%s\\n\\n\\n\\n\" \"$SERIAL_ID\" | ./nocturne-miner >/dev/null 2>&1 || true\r\n\r\nif [ -f ~/night/settings.json ]; then\r\n  echo \"[OK] Initial setup complete! settings.json created.\"\r\nelse\r\n  echo \"[WARN] settings.json not found; setup may have failed.\"\r\nfi\r\n'''\r\n\r\ndef install_on_device(device_id):\r\n    try:\r\n        print(f\"[{device_id}] Starting Nocturne install...\")\r\n\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am force-stop com.termux\", shell=True)\r\n        time.sleep(1)\r\n\r\n        # Generate a device-specific installer with embedded serial\r\n        script_content = install_script_template.format(device_id=device_id)\r\n        \r\n        # FIX: Add newline='\\n' to force Unix line endings\r\n        with tempfile.NamedTemporaryFile(\"w\", encoding=\"utf-8\", delete=False, suffix=\".sh\", newline='\\n') as f:\r\n            f.write(script_content)\r\n            local_script = f.name\r\n\r\n        remote_path = \"/data/local/tmp/nocturne_install.sh\"\r\n        subprocess.run(f'{ADB} -s {device_id} push \"{local_script}\" \"{remote_path}\"', shell=True, check=True)\r\n        subprocess.run(f\"{ADB} -s {device_id} shell chmod 755 {remote_path}\", shell=True, check=True)\r\n\r\n        print(f\"[{device_id}] Launching Termux...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am start -n com.termux/com.termux.app.TermuxActivity\", shell=True)\r\n        time.sleep(8)\r\n\r\n        print(f\"[{device_id}] Executing installer...\")\r\n        typed = f\"bash%s{remote_path}\"\r\n        subprocess.run(f'{ADB} -s {device_id} shell input text \"{typed}\"', shell=True)\r\n        time.sleep(1)\r\n        subprocess.run(f\"{ADB} -s {device_id} shell input keyevent 66\", shell=True)\r\n\r\n        # Give it time to finish\r\n        time.sleep(25)\r\n\r\n        print(f\"[{device_id}] ‚úÖ Nocturne miner installed and initialized.\")\r\n        os.unlink(local_script)\r\n        return f\"[{device_id}] Success\"\r\n\r\n    except Exception as e:\r\n        print(f\"[{device_id}] ‚ùå Error: {e}\")\r\n        return f\"[{device_id}] Error: {e}\"\r\n\r\nif not devices:\r\n    print(\"No devices in $devices\")\r\nelse:\r\n    print(\"=== Starting Nocturne Miner Installation & Initialization (Parallel) ===\")\r\n    with ThreadPoolExecutor(max_workers=max(1, len(devices))) as executor:\r\n        futures = {executor.submit(install_on_device, d): d for d in devices}\r\n        for f in as_completed(futures):\r\n            print(f.result())\r\n    print(\"‚úÖ All installation commands sent.\")",
    "runScript": "import os, time, json, tempfile, subprocess\r\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\r\n\r\nADB = os.environ.get(\"adb_path\", \"adb\")\r\ndevices = os.environ.get(\"devices\", \"\").split()\r\nthreads = os.environ.get(\"threads\", \"8\")\r\nadditional_flags = os.environ.get(\"additional_flags\", \"50\")\r\n\r\ndef adb(cmd):\r\n    return subprocess.run(cmd, shell=True, capture_output=True, text=True)\r\n\r\ndef type_cmd(device_id: str, cmd: str, enter=True, pause=0.35):\r\n    \"\"\"Type a command inside Termux using adb shell input.\"\"\"\r\n    esc = cmd.replace(\" \", \"%s\")\r\n    adb(f'{ADB} -s {device_id} shell input text \"{esc}\"')\r\n    if enter:\r\n        time.sleep(0.25)\r\n        adb(f\"{ADB} -s {device_id} shell input keyevent 66\")\r\n    time.sleep(pause)\r\n\r\ndef push_patch_script(device_id: str, remote_path=\"/data/local/tmp/update_settings.py\"):\r\n    \"\"\"Push a JSON patcher that edits only worker_threads and gen_end_index.\"\"\"\r\n    patch_script = f\"\"\"import json, os\r\npath = os.path.expanduser('~/night/settings.json')\r\ntry:\r\n    with open(path, 'r', encoding='utf-8') as f:\r\n        data = json.load(f)\r\n    data['worker_threads'] = int({threads})\r\n    data['gen_end_index'] = int({additional_flags})\r\n    with open(path, 'w', encoding='utf-8') as f:\r\n        json.dump(data, f, ensure_ascii=False, indent=2)\r\n    print('[OK] Updated settings.json')\r\nexcept Exception as e:\r\n    print('[ERR]', e)\r\n\"\"\"\r\n    # FIX: Added newline='\\n' to force Unix line endings\r\n    with tempfile.NamedTemporaryFile(\"w\", encoding=\"utf-8\", delete=False, newline='\\n') as f:\r\n        f.write(patch_script)\r\n        local = f.name\r\n    adb(f'{ADB} -s {device_id} push \"{local}\" \"{remote_path}\"')\r\n    os.unlink(local)\r\n\r\ndef run_on_device(device_id: str):\r\n    try:\r\n        print(f\"[{device_id}] Starting Nocturne run (interactive typing)...\")\r\n        # Step 1: Stop and restart Termux\r\n        adb(f\"{ADB} -s {device_id} shell am force-stop com.termux\")\r\n        time.sleep(1)\r\n        adb(f\"{ADB} -s {device_id} shell am start -n com.termux/com.termux.app.TermuxActivity\")\r\n        time.sleep(6)\r\n\r\n        # Step 2: Push updater\r\n        push_patch_script(device_id)\r\n        time.sleep(1)\r\n\r\n        # Step 3: Navigate to miner directory\r\n        print(f\"[{device_id}] Typing commands into Termux...\")\r\n        type_cmd(device_id, \"cd ~/night\")\r\n\r\n        # Step 4: Update the settings.json file\r\n        type_cmd(device_id, \"python /data/local/tmp/update_settings.py\", pause=1.5)\r\n\r\n        # Step 5: Start the miner\r\n        type_cmd(device_id, \"./nocturne-miner\", pause=2.5)\r\n\r\n        # Step 6: Simulate 3 √ó Enter presses for defaults\r\n        for _ in range(3):\r\n            adb(f\"{ADB} -s {device_id} shell input keyevent 66\")\r\n            time.sleep(0.6)\r\n\r\n        # Step 7: Keep awake (optional)\r\n        adb(f\"{ADB} -s {device_id} shell svc power stayon true\")\r\n\r\n        print(f\"[{device_id}] ‚úÖ Miner started via interactive Termux typing.\")\r\n        return f\"[{device_id}] Success\"\r\n\r\n    except Exception as e:\r\n        print(f\"[{device_id}] ‚ùå Error: {e}\")\r\n        return f\"[{device_id}] Error: {e}\"\r\n\r\ndef main():\r\n    if not devices:\r\n        print(\"No devices in $devices\")\r\n        return\r\n\r\n    print(\"=== Starting Nocturne Miner (Interactive Typing Mode) ===\")\r\n    with ThreadPoolExecutor(max_workers=max(1, len(devices))) as ex:\r\n        futures = {ex.submit(run_on_device, d): d for d in devices}\r\n        for f in as_completed(futures):\r\n            print(f.result())\r\n\r\nif __name__ == \"__main__\":\r\n    main()",
    "stopScript": "# nocturne_stop.py\r\n# Stop Nocturne miner by killing Termux (and try to kill nocturne-miner if it escaped).\r\n\r\nimport os, subprocess, concurrent.futures\r\n\r\nADB     = os.environ.get(\"adb_path\", \"adb\")\r\ndevices = os.environ.get(\"devices\", \"\").split()\r\n\r\ndef adb(cmd):\r\n    return subprocess.run(cmd, shell=True, capture_output=True, text=True)\r\n\r\ndef stop_on(device_id: str):\r\n    try:\r\n        # Kill any stray Nocturne miner processes (if it‚Äôs running outside Termux session)\r\n        adb(f'{ADB} -s {device_id} shell \"pkill -f nocturne-miner 2>/dev/null || true\"')\r\n\r\n        # Force-stop Termux (kills active foreground miner session)\r\n        adb(f\"{ADB} -s {device_id} shell am force-stop com.termux\")\r\n\r\n        print(f\"[{device_id}] üõë Nocturne miner stopped successfully.\")\r\n    except Exception as e:\r\n        print(f\"[{device_id}] ‚ùå Error stopping miner: {e}\")\r\n\r\ndef main():\r\n    if not devices:\r\n        print(\"No devices in $devices\")\r\n        return\r\n\r\n    print(\"=== Stopping Nocturne Miner on All Devices ===\")\r\n\r\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max(1, len(devices))) as ex:\r\n        futs = [ex.submit(stop_on, d) for d in devices]\r\n        for f in concurrent.futures.as_completed(futs):\r\n            f.result()\r\n\r\n    print(\"‚úÖ All stop commands sent.\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n",
    "uninstallScript": "import os, time, subprocess\r\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\r\n\r\nADB = os.environ.get(\"adb_path\", \"adb\")\r\ndevices = os.environ.get(\"devices\", \"\").split()\r\n\r\ndef uninstall_miner_on_device(device_id):\r\n    \"\"\"Uninstall Nocturne miner from a single device\"\"\"\r\n    try:\r\n        print(f\"[{device_id}] Starting Nocturne miner uninstallation...\")\r\n\r\n        print(f\"[{device_id}] Force stopping Termux...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am force-stop com.termux\", shell=True)\r\n        time.sleep(1)\r\n\r\n        print(f\"[{device_id}] Launching Termux...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell am start -n com.termux/com.termux.app.TermuxActivity\", shell=True)\r\n        time.sleep(3)\r\n\r\n        # Remove the mining directory\r\n        remove_command = \"rm%s-rf%snight\"\r\n        print(f\"[{device_id}] Removing Nocturne miner directory...\")\r\n        subprocess.run(f\"{ADB} -s {device_id} shell input text '{remove_command}'\", shell=True)\r\n        time.sleep(1)\r\n        subprocess.run(f\"{ADB} -s {device_id} shell input keyevent 66\", shell=True)\r\n        time.sleep(2)\r\n\r\n        print(f\"[{device_id}] ‚úÖ Nocturne miner uninstalled successfully!\")\r\n        return f\"[{device_id}] Miner uninstalled\"\r\n\r\n    except Exception as e:\r\n        print(f\"[{device_id}] ‚ùå Error uninstalling miner: {e}\")\r\n        return f\"[{device_id}] Error: {e}\"\r\n\r\nprint(\"=== Uninstalling Nocturne Miner (Parallel) ===\")\r\n\r\nif not devices:\r\n    print(\"No devices specified in $devices environment variable\")\r\nelse:\r\n    with ThreadPoolExecutor(max_workers=len(devices)) as executor:\r\n        future_to_device = {executor.submit(uninstall_miner_on_device, device_id): device_id for device_id in devices}\r\n        for future in as_completed(future_to_device):\r\n            device_id = future_to_device[future]\r\n            try:\r\n                result = future.result()\r\n                print(result)\r\n            except Exception as exc:\r\n                print(f\"[{device_id}] Generated an exception: {exc}\")\r\n\r\n    print(\"üßπ Nocturne miner uninstallation completed on all devices.\")",
    "installTermux": false,
    "installScriptLanguage": "Python",
    "runScriptLanguage": "Python",
    "stopScriptLanguage": "Python",
    "uninstallScriptLanguage": "Python",
    "id": "cef09e39-7465-4ffc-8932-6e80cabf1ee5"
  },
  "timestamp": "2025-11-10T19:26:30.449Z",
  "version": "1.0.0"
}